<!DOCTYPE html>
<!--
Copyright 2011 Google Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

Author: Eric Bidelman (ericbidelman@chromium.org)
-->
<html>
<head>
  <title>Scala Study Part1</title>
  <meta charset="utf-8">
  <meta http-equiv="Content-Style-Type" content="text/css; charset=utf-8" />
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <script src='slides.js'></script>
  <link href="http://fonts.googleapis.com/css?family=Raleway:100" rel="stylesheet" type="text/css">
  <link href="http://fonts.googleapis.com/css?family=Open+Sans:300" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Open+Sans:regular,semibold,italic,italicsemibold|Droid+Sans+Mono&v2">
</head>
<body style="display: none">

<section class='slides layout-regular'>

  <article class="biglogo">
    <script>
      (function() {
        var c = document.createElement('canvas');
        var ctx = null;
        try {
          ctx = c.getContext('webgl');
        } catch(e) { }
        try {
          ctx = ctx || c.getContext('experimental-webgl');
        } catch(e) { }
        if (!ctx) alert("No WebGL detected, live demos disabled!");
      })();
    </script>
  </article>

  <article id="title" class="title">
    <div>
      <h1>CA Scala Study Part1</h1>
      <h2 class="subtitle">Wataru Fukunaga</h2>
      <h3 class="subtitle"><img style="height:60px; padding-left:70px;" src="images/ca_logo.png"></h3>
    </div>
  </article>

  <article>
    <h3>Who am I?</h3>
    <h4>Wataru Fukunaga</h4>
    <p><a href="http://twitter.com/wataru420">@wataru420</a> 
      | <a href="http://ameblo.jp/wataru420">amebaId:wataru420</a>
    <p>Cyberagent Application Engineer</p>
    <br><br>
    <p>Scalaコップ本輪読会用の資料です。</p>
    <br><br>
    <p>Slides available at <a href="http://goo.gl/SVfmP">http://goo.gl/SVfmP</a></p>
    <p>I use this: <a href="https://github.com/kig/BasicsOfThreeJS">github.com/kig/BasicsOfThreeJS</a></p>
      
  </article>

  <article class="title">
    <h2>コップ本輪読会</h2>
    <h3 class="subtitle">第一章〜第三章まで</h3>
  </article>

  <article>
    <h3>Agenda</h3>
    <ul style="font-size:120%">
      <li>第一章　スケーラブルな言語</li>
      <li>第二章　Scalaプログラミングの第一歩</li>
      <li>第三章　Scalaプログラミングの次の一歩</li>
    </ul>
    <br><br>
    <ul class="build">
	<p style="font-size:200%">コップが溢れる程</p>
	<p style="font-size:200%">　　　　　Scalaを愛したい</p>
    </ul>

  </article>

  <article>
    <h3>第一章スケーラブルな言語</h3>
    <ul style="font-size:40%">
	  <li>１．１．プログラマーとともに成長する言語</li>
      <li>１．１．１新しい型を作れる言語</li>
      <li>１．１．２新しい制御構造を作れる言語</li>
      <li>１．２．Scalaがスケーラブルな理由</li>
      <li>１．２．１Scalaはオブジェクト指向</li>
      <li>１．２．２Scalaは関数型言語</li>
      <li>１．３．Scalaを選ぶ理由</li>
      <li>１．３．１互換性（Javaとの共存）</li>
      <li>１．３．２簡潔性（Javaの半分以下のコード量）</li>
      <li>１．３．３高水準（抽象度の高いコード、新しい制御構造を定義できる表現力）</li>
      <li>１．３．４静的な型付け（簡潔性、柔軟性、検証可能性、安全性、ドキュメント性）</li>
      <li>１．４．scalaのさまざまなルーツ
      <li>１．５．まとめ
    </ul>
  </article>

  <article class="title">
    <h2>A Scalable Language</h2>
  </article>

  <article>
  <h3>A Scalable Language</h3>
    <p>Scalaの名前の由来</p>
    <p>ユーザーの求めに応じて成長できるよう設計</p>
    <p>Javaプラットフォーム上で動くので間口も広い</p>
    <br><br>
	<p>Scalaはオブジェクト指向と関数型プログラミングの概念を、静的な型付けを行う言語にまとめ上げたものである。</p>
    <br><br>
    <ul class="build">
	<p>みんなでScalaを使えるかっこいいエンジニアになろう！！</p>
    </ul>
  </article>

  <article class="title">
    <h2 style="font-size:130%">プログラマーとともに成長する言語</h2>
  </article>

  <article>
  <h3>about Map</h3>
    <pre>

var capital = Map("US" -> "Washington", "France" -> "Paris")
capital += ("Japan" -> "Tokyo")
println(capital("France"))
	</pre>
    <p>Perl、Python、Rubyなどのスクリプト言語のような感じ</p>
    <br><br>
    <ul class="build">
    <p>連想マップは便利</p>
    <p>でも、フリーサイズで誰でも着られるみたいなのは嫌だ</p>
    </ul>
  </article>

  <article>
  <h3>HashMap</h3>
    <p>さっきのをHashMapに書き換えてみます</p>
    <pre>

import scala.collection.imutable.HashMap

var capital = HashMap("US" -> "Washington", "France" -> "Paris")
capital += ("Japan" -> "Tokyo")
println(capital("France"))
	</pre>
    <p>簡単ですね</p>
  </article>

  <article>
  <h3>TreeMap</h3>
    <p>さっきのをTreeMapに書き換えてみます</p>
    <pre>

import scala.collection.immutable.TreeMap

var capital = TreeMap("US" -> "Washington", "France" -> "Paris")
capital += ("Japan" -> "Tokyo")
println(capital("France"))
	</pre>
    <p>簡単ですね</p>
  </article>

  <article>
  <h3>SynchronizedMap</h3>
    <p>SynchronizedMapトレイトでスレッドセーフに</p>
    <pre>

import scala.collection.mutable.{ HashMap, SynchronizedMap }

var capital = new HashMap[String,String] with 
                             SynchronizedMap[String,String]
capital += ("US" -> "Washington", "France" -> "Paris")
capital += ("Japan" -> "Tokyo")
println(capital("France"))
	</pre>
    <p>このようにScalaは柔軟で書きやすく、そして必要に応じて細かく修正していける</p>
  </article>

  <article class="title">
    <h2 style="font-size:130%">新しい型を作れる言語</h2>
  </article>

  <article>
    <h3>Type</h3>
    <br>
    <p>Scalaは型を簡単に作れる</p>
    <p>Scalaは型を使った条件分岐ができる</p>
    <p>Scalaは型に関する機能が豊富</p>
    <p>型に積極的な意味をもたせられる</p>
    <br><br>
    <p>メソッドやメンバ変数を束ねるだけのものではない！</p>
  </article>

  <article>
    <h3>BigInt</h3>
    <br>
    <p>javaのBigIntegerはint型とはだいぶ異なる</p>
    <br><br>
	<p>ScalaではこのBigIntegerをラップした<a href="http://harrah.github.com/browse/samples/library/scala/BigInt.scala.html" target="blank">BigIntクラス</a>がある</p>
    <p>＊などの演算子があたかも予約語かのように使える</p>
  </article>

  <article>
    <h3>Pattern Match</h3>
    <br>
	<p>Caseクラスとパターンマッチを使うと、<br>型に意味を持たせられる</p>
    <pre>

def eval(e: Expr): Int = e match {
  case Number(x) => x
  case Sum(l, r) => eval(l) + eval(r)
}
</pre>
    <p>Scalaのパターンマッチはかなり強力</p>
  </article>

  <article class="title">
    <h2 style="font-size:130%">新しい制御構造を作れる言語</h2>
  </article>

  <article>
    <h3>Actor</h3>
    <pre>

recipient ! msg

val recipient = actor {
  loop {
    recive{
      case Msg1 => … //Msg1の処理
      case Msg2 => … //Msg2の処理
      // …
    }
  }
}
	</pre>
	<p>ScalaはErlangのアクターモデルを実装している</p>
  </article>

  <article>
    <h3>Actor</h3>
  	<p>メッセージ送信（!）やactor、loop、receive</p>
	<p>いずれも組み込み演算ではない</p>
	<p>Scalaのアクターライブラリーで定義されている</p>
    <br>
	<p>Scalaの中で新しい言語を作ることすら可能</p>
	<p>興味があったら<a href="http://d.hatena.ne.jp/nowokay/20111109#1320815540" target="blank">Scalaでパーサーを作ってみる</a>を見てね</p>
  </article>

  <article class="title">
    <h2 style="font-size:130%">Scalaがスケーラブルな理由</h2>
    <h3 class="subtitle" style="font-size:100%">またはオブジェクト指向と関数型プログラミングの融合</h3>
  </article>

  <article class="title">
    <h2 style="font-size:130%">Scalaはオブジェクト指向</h2>
  </article>

  <article>
    <h3>Java is OOP?</h3>
    <br><br>
    <h4>Javaにはプリミティブ型がある。</h4>
    <br><br>
	<p>これはリフレクションを複雑にするなど、<br>スケーラビリティを下げている。</p>
    <br><br>
    <p>純粋なオブジェクト指向じゃないよね</p>
  </article>

  <article>
    <h3>Scala is Pure OOP</h3>
    <br><br>
    <h4>Scalaは純粋なオブジェクト指向</h4>
	<pre>

1 + 2
    </pre>
	<p>+ は演算子に見えるが、Intオブジェクトのメソッド</p>
  </article>

  <article>
    <h3>Composition</h3>
    <br>
	<h4>Scalaはオブジェクトの合成能力がすごい</h4>
    <br><br>
	<p>Traitはメソッドとフィールドをカプセル化したもの。</p>
	<p>Traitを使うとミックスインのような事が可能となる。</p>
  </article>

  <article class="title">
    <h2 style="font-size:130%">Scalaは関数型言語</h2>
  </article>

  <article>
    <h3>first class values</h3>
	<h4>Scalaでは関数もリテラル</h4>
    <pre>

//普通の関数
def 関数名(引数:型, …) = 本体
//関数リテラル
(引数:型, …) => 本体

//こんな風に使える
args.foreach(arg => println(arg))
    </pre>
  </article>

  <article>
    <h3>Imutable</h3>
	<h4>メソッドは副作用を持ってはいけない</h4>
    <br><br>
	<p>Scalaは完璧ではない</p>
	<p>イミュータブルなデータ構造多く用意している</p>
	<p>つまり副作用のないメソッドを容易に作れる</p>
  </article>


  <article class="title">
    <h2 style="font-size:130%">Scalaを選ぶ理由</h2>
  </article>

  <article>
    <h3>Compatibility</h3>
	<h4>互換性（Javaとの共存）</h4>
    <br><br>
	<p>ScalaはJavaのライブラリーを多用している。</p>
	<p>ScalaからJavaを使うために特別な構文などはない。</p>
	<p>実際MyBatisとかもさくっと使えました。</p>
  </article>

  <article>
    <h3>Elegant</h3>
	<h4>簡潔性</h4>
    <pre>

//これはJava
class MyClass {
  private int index;
  private String name;
  public MyClass(int index, String name) {
    this.index = index;
    this.name = name;
  }
}
    </pre>
  </article>

  <article>
    <h3>Elegant</h3>
	<h4>簡潔性（Javaの半分以下のコード量）</h4>
	<br>
	<pre>

// Scalaならこれだけ
class MyClass(index: Int, name: String)
    </pre>
	<p>行数が減れば入力が楽、そして理解する労力も減る？</p>
  </article>

  <article>
    <h3>high-level programming language</h3>
	<h4>高水準</h4>
	<p>例えばStringの変数の中に大文字があるかどうかを知る関数</p>
    <pre>

// Java
boolean nameHasUpperCase = false;
for (int i = 0; i < name.length(); ++i) {
    if (Character.isUpperCase(name.charAt(i))) {
        nameHasUpperCase = true;
        break;
    }
}
	</pre>
  </article>

  <article>
    <h3>high-level programming language</h3>
	<h4>抽象度の高いコード、新しい制御構造を定義できる表現力</h4>
    <pre>

val nameHasUpperCase = name.exists(_.isUpperCase)
	</pre>
	<p>文字列をより高い水準の存在として扱い、<br>複雑さを緩和している。</p>
	<p>Javaでも似たような制御構造を作ることは可能だが面倒。</p>
	<p>関数リテラルはプログラムは短くてキレイなものとする。</p>
  </article>

  <article>
    <h3>Static Typing</h3>
	<h4>簡潔性とか大丈夫なの？</h4>
	<p>静的型付け言語は一般的には冗長だと言われている</p>
	<p>型を指定しないとかけない。</p>
	<p>コーディング量が増える。</p>
    <br><br>
    <ul class="build">
	<p>Scalaでは強力な型推論があるので簡潔に書ける。</p>
    </ul>
  </article>

  <article>
    <h3>Static Typing</h3>
	<h4>柔軟性とかないよね？</h4>
	<p>型が静的である事自体が制限になる。</p>
	<p>将来の変化の足かせになる。</p>
    <br><br>
    <ul class="build">
	<p>Scalaではパターンマッチングと強力な合成の力で<br>かなり柔軟に書ける。</p>
    </ul>
  </article>

  <article>
    <h3>Static Typing</h3>
	<h4>検証可能性</h4>
	<p>真偽値が整数に加算されていない</p>
	<p>文字列の集合に文字列以外が追加されない</p>
	<p>コンパイル時に検出可能</p>
    <br><br>
    <ul class="build">
	<p>テストで証明できるのはエラーの存在だけ</p>
	<p>エラーの不在ではない！</p>
    </ul>
  </article>

  <article>
    <h3>Static Typing</h3>
	<h4>安全なリファクタリング</h4>
	<p>コンパイル時に検出されるエラーがリファクタリング時のセーフティネットとなる。</p>
    <br><br>
    <ul class="build">
	<p>影響範囲の特定が楽</p>
    </ul>
  </article>

  <article>
    <h3>Static Typing</h3>
	<h4>ドキュメント性の向上</h4>
    <pre>def f(x: String) = …</pre>
	<p>fの引数がStringでなければならないことがわかる。</p>
	<p>ただ、これはやだ</p>
    <pre>val x: HashMap[Int, String] = new HashMap[Int, String]()</pre>
	<pre>
val x = new HashMap[Int, String]()
val x: Map[Int, String] = new HashMap()</pre>
	<p>型推論してくれるScalaならこれでいい</p>
  </article>

  <article class="title">
  <h2 style="font-size:130%">Scalaのさまざまなルーツ</h2>
  </article>

  <article>
    <h3>Roots</h3>
    <br>
    <ul class="build">
    <li>表面的なレベルではJavaとC#の構文を多く採用</li>
    <li>徹底したオブジェクトモデルはSmalltalk、Ruby</li>
    <li>普遍的なネストの考え方でAlgol、Simula等</li>
    <li>高階関数はHaskell等</li>
    <li>アクターベースの並行処理でErlang</li>
    <li>etc...</li>
    </ul>
  </article>

  <article class="title">
  <h2 style="font-size:130%">まとめ</h2>
  </article>

  <article>
    <h3>We will love Scala</h3>
    <br>
    <ul class="build">
    <li>Scalaは色々便利そう</li>
    <li>だけど、しっかり勉強しないと使えない</li>
    <li>Javaからの移行だと、型システムと関数型が難しそう</li>
    </ul>
    <img style="padding-left:70%;" src="images/pile_of_books.jpg">
  </article>

  <article class="title">
  <h2 style="font-size:130%">Scalaプログラミングの第一歩</h2>
  </article>

  <article>
    <h3>First Step</h3>
    <ul style="font-size:60%">
	  <li>２．１［ステップ１］Scalaインタープリターの使い方を学ぶ</li>
      <li>２．２［ステップ２］変数を定義する</li>
      <li>２．３［ステップ３］関数を定義する</li>
      <li>２．４［ステップ４］簡単なScalaスクリプトを書く</li>
      <li>２．５［ステップ５］whileによるループ、ifによる分岐</li>
      <li>２．６［ステップ６］foreachとforによる反復実行</li>
      <li>２．７まとめ</li>
    </ul>
    <img style="padding-left:70%;" src="images/first_step.jpg">
  </article>

  <article class="title">
  <h2 style="font-size:130%">Scalaインタープリターの使い方を学ぶ</h2>
    <h3 class="subtitle">Step1</h3>
  </article>

  <article>
    <h3>Step1</h3>
	<pre>
$scala

scala> 1 + 2

res0: Int = 3</pre>
	<p>計算された値を参照する自動生成またはユーザー定義で作られた名前</p>
	<p>コロンと式の型</p>
	<p>等号</p>
	<p>式評価の結果</p>
  </article>

  <article>
    <h3>Step1</h3>
	<p>res0は実際に使える</p>
	<pre>
scala> res0 * 3

res1: Int = 9</pre>
	<br>
    <p>みんなの大好き「Hello world」</p>
    <pre>
scala> println("Hello, world!")

Hello, world!</pre>
  </article>

  <article class="title">
  <h2 style="font-size:130%">変数を定義する</h2>
    <h3 class="subtitle">Step2</h3>
  </article>

  <article>
    <h3>Step2</h3>
	<p>res0は実際に使える</p>
	<pre>
scala> val msg = "Hello, world!"
msg: java.lang.String = Hello, world!</pre>
    <p>型を明示的に指定したいときは</p>
	<pre>
scala> val msg2: java.lang.String = "Hello, world!"
msg2: java.lang.String = Hello, world!

scala> val msg3: String = "Hello, world!"
msg3: String = Hello, world!</pre>
    <p>こんな風に使えます</p>
	<pre>
scala> println(msg)
Hello, world!</pre>
  </article>

  <article>
    <h3>Step2</h3>
	<p>valは定数、Javaでいうfinal</p>
	<pre>
scala> msg = "Goodbye cruel world!"
&lt;console>:8: error: reassignment to val
       msg = "Goodbye cruel world!"</pre>
    <p>varが変数</p>
	<pre>
scala> var greeting = "Hello, world!"
greeting: java.lang.String = Hello, world!

scala> greeting = "Leave me alone, world!"
greeting: java.lang.String = Leave me alone, world!</pre>
  </article>

  <article>
    <h3>Step2</h3>
	<p>複数行にまたがる入力は、うまいことやってくれる</p>
	<pre>
scala> val multilLine =
     |   "This is next line."
multilLine: java.lang.String = This is next line.</pre>
    <p>縦棒（|）が表示されて入力を続けられる。</p>
    <p>間違えたら[Enter]２回</p>
	<pre>
scala> val oops =
     |
     |
You typed two blank lines.  Starting a new command.</pre>
  </article>

  <article class="title">
  <h2 style="font-size:130%">関数を定義する</h2>
    <h3 class="subtitle">Step3</h3>
  </article>

  <article>
    <h3>Step3</h3>
	<h4>関数はdef</h4>
	<pre>
scala> def max(x: Int, y: Int): Int = {
             if (x > y) x
             else y
           }
max: (Int, Int)Int</pre>
    <p>def 関数名(引数:型, …) = 本体)</p>
    <p>関数が再帰的な場合などは結果型の指定が必要だが、今回は省略できる。</p>
	<pre>
scala> def max2(x: Int, y: Int) = if (x > y) x else y</pre>
  </article>

  <article>
    <h3>Step3</h3>
	<p>結果を返さない関数もある</p>
	<pre>
scala> def greet() = println("Hello, world!")
greet: ()Unit</pre>
    <p>Utin型はJavaのvoid型みたいなもの</p>
    <p>終了は</p>
	<pre>
scala> :quit
$</pre>
  </article>

  <article class="title">
  <h2 style="font-size:130%">簡単なScalaスクリプトを書く</h2>
    <h3 class="subtitle">Step4</h3>
  </article>

  <article>
    <h3>Step4</h3>
	<p>hello.scala</p>
	<pre>println("Hello, world, from a script!")</pre>
	<pre>$ scala hello.scala</pre>
    <p>もちろん引数も渡せる。</p>
    <p>helloarg.scala</p>
	<pre>println("Hello, " + arg(0) + "!")</pre>
	<pre>$ scala helloarg.scala planet</pre>
  </article>

  <article class="title">
  <h2 style="font-size:130%">whileによるループ、ifによる分岐</h2>
    <h3 class="subtitle">Step5</h3>
  </article>

  <article>
    <h3>Step5</h3>
	<h4>while</h4>
    <p>printargs.scala</p>
	<pre>
var i = 0
while (i < args.length) {
  println(args(i))
  i += 1
}</pre>
    <p>このプログラムはあまり良くないがとりあえずwhileの説明</p>
  </article>

  <article>
    <h3>Step5</h3>
	<h4>if</h4>
    <p>echoargs.scala</p>
	<pre>
var i = 0
while (i < args.length) {
  if (i != 0)
    print(" ")
  println(args(i))
  i += 1
}
println()</pre>
    <p>このプログラムはあまり良くないがとりあえずwhileの説明</p>
  </article>

  <article class="title">
  <h2 style="font-size:130%">foreachとforによる反復実行</h2>
    <h3 class="subtitle">Step6</h3>
  </article>

  <article>
    <h3>Step6</h3>
	<h4>whileは命令形、イケてない</h4>
    <p>foreachを使おう</p>
	<pre>args.foreach(arg => println(arg))</pre>
	<pre>args.foreach((arg: String) => println(arg))</pre>
	<pre>arg.foreach(println)</pre>
  </article>

  <article>
    <h3>Step6</h3>
	<h4>for式もある</h4>
	<pre>
for (arg <- args)
  println(arg)</pre>
    <p>しかしfor式はこんなもんじゃない</p>
    <ul class="build">
    <p>詳しくは7.3節と第23章で</p>
    </ul>
  </article>

  <article class="title">
  <h2 style="font-size:130%">まとめ</h2>
  </article>

  <article>
	<h4>Scala結構いけそうじゃね？</h4>
    <br><br>
    <br><br>
    <img style="padding-left:50%;" src="images/tenshin.jpg">
  </article>

  <article class="title">
  <h2 style="font-size:130%">Scalaプログラミングの次の一歩</h2>
  </article>

  <article>
    <h3>Next Step</h3>
    <ul style="font-size:60%">
	  <li>３．１［ステップ７］配列を型でパラメータ化する</li>
      <li>３．２［ステップ８］リストを使う</li>
      <li>３．３［ステップ９］タプルを使う</li>
      <li>３．４［ステップ１０］集合とマップを使う</li>
      <li>３．５［ステップ１１］関数型のスタイルを見分ける</li>
      <li>３．６［ステップ１２］ファイルから行を読み出す</li>
      <li>３．７まとめ</li>
    </ul>
    <img style="padding-left:70%;:" src="images/next_step.jpg">
  </article>

  <article class="title">
  <h2 style="font-size:130%">配列を型でパラメータ化する</h2>
    <h3 class="subtitle">Step7</h3>
  </article>

  <article>
    <h3>Step7</h3>
	<h4>パラメータ化とは、インスタンスの構成を設定すること</h4>
    <p>Javaでいうジェネリクス</p>
	<pre>
val greetStrings = new Array[String](3)
greetStrings(0) = "Hello"
greetStrings(1) = ", "
greetStrings(2) = "world¥n"
for (i <- 0 to 2)
  print(greetStrings(i))</pre>
  </article>

  <article>
    <h3>Step7</h3>
    <p>丁寧に書くと</p>
	<pre>val greetStrings: Array[String]= new Array[String](3)</pre>
	<pre>greetStrings(0)</pre>
    <p>valの中身を書き換えている</p>
	<pre>0 to 2</pre>
    <p>内部的には</p>
	<pre>(0).to(2)</pre>
    <p>パラメータが１つならドットと括弧を省略できる</p>
  </article>

  <article>
    <h3>Step7</h3>
    <h4>Scalaは全ての演算がメソッド</h4>
	<pre>
greetString(0) = "Hello"
greetStrings.update(0, "Hello")</pre>
	<pre>
val numNames = Array("zero", "one", "two")
val numNames2 = Array.apply("zero", "one", "two")</pre>
    <p>上下で同じ意味</p>
    <p>applyはArrayコンパニオンオブジェクトで定義されている</p>
    <ul class="build">
    <p>詳しくは4.3章</p>
    </ul>
  </article>

  <article class="title">
  <h2 style="font-size:130%">リストを使う</h2>
    <h3 class="subtitle">Step8</h3>
  </article>

  <article>
    <h3>Step8</h3>
    <h4>メソッドは副作用を持ってはいけない</h4>
    <p>Array[String]は中身が変更できるからミュータブル</p>
    <br><br>
    <p>ScalaのListはイミュータブル</p>
	<pre>
val oneTwo = List(1, 2)
val threeFour = List(3, 4)
val oneTwoThreeFour = oneTwo ::: threeFour
println(" " + oneTwo + " and " + threeFour + " were not mutated.")
println("Thus, " + oneTwoThreeFour + " is a new list.")</pre>
  </article>

  <article>
    <h3>Step8</h3>
    <h4>よく使うCons</h4>
    <br><br>
	<pre>
val twoThree = List(2, 3)
val oneTwoThree = 1 :: twoThree
println(oneTwoThree)</pre>
    <p>メソッド名末尾がコロンの場合は右被演算子</p>
  </article>

  <article class="title">
  <h2 style="font-size:130%">タプルを使う</h2>
    <h3 class="subtitle">Step9</h3>
  </article>

  <article>
    <h3>Step9</h3>
    <h4>それは便利なコンテナオブジェクト</h4>
    <br><br>
	<pre>
val pair = (99, "Luftballons")
println(pair._1)
println(pair._2)</pre>
    <p>1から始まるのは静的に型付されたタプルの伝統</p>
  </article>

  <article class="title">
  <h2 style="font-size:130%">集合とマップを使う</h2>
    <h3 class="subtitle">Step10</h3>
  </article>

  <article>
    <h3>Step10 Set</h3>
    <h4>imutableなSet</h4>
	<pre>
var jetSet = Set("Boeing", "Airbus")
jetSet += "Lear"
println(jetSet.contains("Cessna"))</pre>
    <p>内部的にはこうなってる</p>
	<pre>jetSet = jetSet + "Lear"</pre>
  </article>

  <article>
    <h3>Step10 Set</h3>
    <h4>mutableなSet</h4>
	<pre>
import scala.collection.mutable.Set
val movieSet = Set("Hitch", "Poltergeist")
movieSet += "Shrek"
println(movieSet)</pre>
    <h4>HushSetが必要なら</h4>
	<pre>
import scala.collection.immutable.HashSet
val hashSet = HashSet("Tomatoes", "Chilies")
println(hashSet + "Coriander")</pre>
  </article>

  <article>
    <h3>Step10 Map</h3>
    <h4>mutableなMap</h4>
	<pre>
import scala.collection.mutable.Map
val treasureMap = Map[Int, String]()
treasureMap += (1 -> "Go to island.")
treasureMap += (2 -> "Find big X on ground.")
treasureMap += (1 -> "Dig.")
println(treasureMap(2))</pre>
    <p>下の二つは同じ意味</p>
	<pre>
1 -> "Go to island."
(1).->("Go to island.")</pre>
    <p>(1,"Go to island.")というタプルを返す</p>
  </article>

  <article>
    <h3>Step10 Map</h3>
    <br><br>
    <h4>imutableなMap</h4>
	<pre>
val romanNumeral = Map (
  1 -> "I", 2 -> "II", 3 -> "III", 4 -> "IV", 5 -> "V"
)
println(romanNumeral(4))</pre>
  </article>

  <article class="title">
  <h2 style="font-size:130%">関数型のスタイルを見分ける</h2>
    <h3 class="subtitle">Step11</h3>
  </article>

  <article>
    <h3>Step11</h3>
    <h4>varをなくそう</h4>
	<pre>
def printArgs(args: Array[String]): Unit = {
  var i = 0
  while (i < args.length){
    println(args(i))
    i += 1
  }
}</pre>
    <p>どうする？</p>
  </article>

  <article>
    <h3>Step11</h3>
    <h4>varをなくした</h4>
	<pre>
def printArgs(args: Array[String]): Unit = {
  for (arg -> args)
    println(arg)
}</pre>
    <p>まだいける</p>
	<pre>
def printArgs(args: Array[String]): Unit = {
  args.foreach(println)
}</pre>
  </article>

  <article>
    <h3>Step11</h3>
    <h4>副作用をなくせ</h4>
    <p>真の関数型は意味のある何かを産み出す</p>
	<pre>
def formatArgs(args: Array[String]) = args.mkString("¥n")

println(formatArgs(args))</pre>
    <p>副作用を持つコードを最小化することでテストしやすく</p>
    <br><br>
    <p>ただ、varが正しい場合もあるのでそのへんはバランス</p>
  </article>

  <article class="title">
  <h2 style="font-size:130%">ファイルから行を読み出す</h2>
    <h3 class="subtitle">Step12</h3>
  </article>

  <article>
    <h3>Step12</h3>
    <h4>とにかく読んでみる</h4>
	<pre>
import scala.io.Source

if (args.length > 0) {
  for (line <- Source.fromFile(args(0)).getLines)
    println(line.length + " " + line)
}
else 
  Console.err.println("Please enter filename")</pre>
  </article>

  <article>
    <h3>Step12</h3>
    <h4>こんな風に出力したい</h4>
	<pre>
22 | import scala.io.Source
 0 |
22 | if (args.length > 0) {
49 |   for (line <- Source.fromFile(args(0)).getLines)
39 |       println(line.length + " " + line)
 1 | }
 5 | else
46 |   Console.err.println("Please enter filename")</pre>
  </article>

  <article>
    <h3>Step12</h3>
    <h4>じゃーーん</h4>
	<pre>
import scala.io.Source
def widthOfLength(s: String) = s.length.toString.length
if (args.length > 0) {
  val lines = Source.fromFile(args(0)).getLines.toList
  var maxWidth = 0
  for (line <- lines)
    maxWidth = maxWidth.max(widthOfLength(line))
  for (line <- lines) {
    val numSpaces = maxWidth - widthOfLength(line) //プリミス
    val padding = " " * numSpaces
    println(padding + line.length + " | " + line)
  }
}
else
  Console.err.println("Please enter filename")</pre>
  </article>

  <article>
    <h3>Step12</h3>
    <h4>もっと関数型に</h4>
	<pre>
import scala.io.Source
def widthOfLength(s: String) = s.length.toString.length
if (args.length > 0) {
  val lines = Source.fromFile(args(0)).getLines.toList
  val longestLine = lines.reduceLeft(
    (a, b) => if (a.length > b.length) a else b
  )
  val maxWidth = widthOfLength(longestLine)
  for (line <- lines) {
    val numSpaces = maxWidth - widthOfLength(line) 
    val padding = " " * numSpaces
    println(padding + line.length + " | " + line)
  }
}
else
  Console.err.println("Please enter filename")</pre>
  </article>

  <article class="title">
  <h2 style="font-size:200%">まとめ</h2>
  </article>
  
  <article>
    <h4>難しいけど面白い</h4>
    <h4>魔法使い目指してがんばろう！</h4>
    <a href="http://subtech.g.hatena.ne.jp/secondlife/20090701/1246418689" target="blank">
    <img style="padding-left:50%;" src="http://cdn-ak.f.st-hatena.com/images/fotolife/k/kumajet/20090701/20090701122032.jpg"></a>
  </article>


  <article>
    <h3>The End</h3>
    <p>Wataru Fukunaga</p>
    <p><a href="http://twitter.com/wataru420">@wataru420</a> 
      | <a href="http://ameblo.jp/wataru420">amebaId:wataru420</a>
    <br><br>
    <p>Slides available at <a href="http://goo.gl/SVfmP">http://goo.gl/SVfmP</a></p>
    <p>Repo at <a href="https://github.com/wataru420/EffectiveJava/tree/master/src/part8">github.com/wataru420/EffectiveJava</a></p>
 
  </article>

</section>
<script type="text/javascript">

	var _gaq = _gaq || [];
	_gaq.push(['_setAccount', 'UA-27158263-1']);
	_gaq.push(['_trackPageview']);

	(function() {
	 var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
	 ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
	 var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
	 })();

</script>
<!--[if IE]>
<script src="http://ajax.googleapis.com/ajax/libs/chrome-frame/1/CFInstall.min.js"></script>
<script>CFInstall.check({mode: 'overlay'});</script>
<![endif]-->

</body>
</html>
