<!DOCTYPE html>
<!--
Copyright 2011 Google Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

Author: Eric Bidelman (ericbidelman@chromium.org)
-->
<html>
<head>
  <title>Scala Study Part1</title>
  <meta charset="utf-8">
  <meta http-equiv="Content-Style-Type" content="text/css; charset=utf-8" />
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <script src='slides.js'></script>
  <link href="http://fonts.googleapis.com/css?family=Raleway:100" rel="stylesheet" type="text/css">
  <link href="http://fonts.googleapis.com/css?family=Open+Sans:300" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Open+Sans:regular,semibold,italic,italicsemibold|Droid+Sans+Mono&v2">
</head>
<body style="display: none">

<section class='slides layout-regular'>

  <article class="biglogo">
    <script>
      (function() {
        var c = document.createElement('canvas');
        var ctx = null;
        try {
          ctx = c.getContext('webgl');
        } catch(e) { }
        try {
          ctx = ctx || c.getContext('experimental-webgl');
        } catch(e) { }
        if (!ctx) alert("No WebGL detected, live demos disabled!");
      })();
    </script>
  </article>

  <article id="title" class="title">
    <div>
      <h1>CA Scala Study Part1</h1>
      <h2 class="subtitle">Wataru Fukunaga</h2>
      <h3 class="subtitle"><img style="height:60px; padding-left:70px;" src="images/ca_logo.png"></h3>
    </div>
  </article>

  <article>
    <h3>Who am I?</h3>
    <p>Wataru Fukunaga</p>
    <p><a href="http://twitter.com/wataru420">@wataru420</a> 
      | <a href="http://ameblo.jp/wataru420">amebaId:wataru420</a>
    <p>Cyberagent Application Engineer</p>
    <br><br>
    <p>Scalaコップ本輪読会用の資料です。</p>
    <br><br>
    <p>Slides available at <a href="http://goo.gl/SVfmP">http://goo.gl/SVfmP</a></p>
    <p>I use this: <a href="https://github.com/kig/BasicsOfThreeJS">github.com/kig/BasicsOfThreeJS</a></p>
      
  </article>

  <article class="title">
    <h2>コップ本輪読会</h2>
    <h3 class="subtitle">第一章〜第三章まで</h3>
  </article>

  <article>
    <h3>Agenda</h3>
    <ul style="font-size:120%">
      <li>第一章　スケーラブルな言語</li>
      <li>第二章　Scalaプログラミングの第一歩</li>
      <li>第三章　Scalaプログラミングの次の一歩</li>
    </ul>
  </article>

  <article>
    <h3>第一章スケーラブルな言語</h3>
    <ul style="font-size:40%">
	  <li>１．１．プログラマーとともに成長する言語</li>
      <li>１．１．１新しい型を作れる言語</li>
      <li>１．１．２新しい制御構造を作れる言語</li>
      <li>１．２．Scalaがスケーラブルな理由</li>
      <li>１．２．１Scalaはオブジェクト指向</li>
      <li>１．２．２Scalaは関数型言語</li>
      <li>１．３．Scalaを選ぶ理由</li>
      <li>１．３．１互換性（Javaとの共存）</li>
      <li>１．３．２簡潔性（Javaの半分以下のコード量）</li>
      <li>１．３．３高水準（抽象度の高いコード、新しい制御構造を定義できる表現力）</li>
      <li>１．３．４静的な型付け（簡潔性、柔軟性、検証可能性、安全性、ドキュメント性）</li>
      <li>１．４．calaのさまざまなルーツ
      <li>１．５．まとめ
    </ul>
  </article>

  <article class="title">
    <h2>A Scalable Language</h2>
  </article>

  <article>
  <h3>A Scalable Language</h3>
    <p>Scalaの名前の由来</p>
    <p>ユーザーの求めに応じて成長できるよう設計</p>
    <p>Javaプラットフォーム上で動くので間口も広い</p>
    <br><br>
	<p>Scalaはオブジェクト指向と関数型プログラミングの概念を、静的な型付けを行う言語にまとめ上げたものである。</p>
    <br><br>
	<p>みんなでScalaを使えるかっこいいエンジニアになろう！！</p>
  </article>

  <article class="title">
    <h2 style="font-size:130%">プログラマーとともに成長する言語</h2>
  </article>

  <article>
  <h3>about Map</h3>
    <pre>

var capital = Map("US" -> "Washington", "France" -> "Paris")
capital += ("Japan" -> "Tokyo")
println(capital("France"))
	</pre>
    <p>Perl、Python、Rubyなどのスクリプト言語のような感じ</p>
    <br><br>
    <ul class="build">
    <p>連想マップは便利</p>
    <p>でも、フリーサイズで誰でも着られるみたいなのは嫌だ</p>
    </ul>
  </article>

  <article>
  <h3>HashMap</h3>
    <p>さっきのをHashMapに書き換えてみます</p>
    <pre>

import scala.collection.imutable.HashMap

var capital = HashMap("US" -> "Washington", "France" -> "Paris")
capital += ("Japan" -> "Tokyo")
println(capital("France"))
	</pre>
    <p>簡単ですね</p>
  </article>

  <article>
  <h3>TreeMap</h3>
    <p>さっきのをTreeMapに書き換えてみます</p>
    <pre>

import scala.collection.immutable.TreeMap

var capital = TreeMap("US" -> "Washington", "France" -> "Paris")
capital += ("Japan" -> "Tokyo")
println(capital("France"))
	</pre>
    <p>簡単ですね</p>
  </article>

  <article>
  <h3>SynchronizedMap</h3>
    <p>SynchronizedMapトレイトでスレッドセーフに</p>
    <pre>

import scala.collection.mutable.{ HashMap, SynchronizedMap }

var capital = new HashMap[String,String] with 
                             SynchronizedMap[String,String]
capital += ("US" -> "Washington", "France" -> "Paris")
capital += ("Japan" -> "Tokyo")
println(capital("France"))
	</pre>
    <p>このようにScalaは柔軟で書きやすく、そして必要に応じて細かく修正していける</p>
  </article>

  <article class="title">
    <h2 style="font-size:130%">新しい型を作れる言語</h2>
  </article>

  <article>
    <h3>Type</h3>
    <br>
    <p>Scalaは型を簡単に作れる</p>
    <p>Scalaは型を使った条件分岐ができる</p>
    <p>Scalaは型に関する機能が豊富</p>
    <p>型に積極的な意味をもたせられる</p>
    <br><br>
    <p>メソッドやメンバ変数を束ねるだけのものではない！</p>
  </article>

  <article>
    <h3>BigInt</h3>
    <br>
    <p>javaのBigIntegerはint型とはだいぶ異なる</p>
    <br><br>
	<p>ScalaではこのBigIntegerをラップした<a href="http://harrah.github.com/browse/samples/library/scala/BigInt.scala.html" target="blank">BigIntクラス</a>がある</p>
    <p>＊などの演算子があたかも予約語かのように使える</p>
  </article>

  <article>
    <h3>Pattern Match</h3>
    <br>
	<p>Caseクラスとパターンマッチを使うと、<br>型に意味を持たせられる</p>
    <pre>

def eval(e: Expr): Int = e match {
  case Number(x) => x
  case Sum(l, r) => eval(l) + eval(r)
}
</pre>
    <p>Scalaのパターンマッチはかなり強力</p>
  </article>

  <article class="title">
    <h2 style="font-size:130%">新しい制御構造を作れる言語</h2>
  </article>

  <article>
    <h3>Actor</h3>
    <pre>

recipient ! msg

val recipient = actor {
  loop {
    recive{
      case Msg1 => … //Msg1の処理
      case Msg2 => … //Msg2の処理
      // …
    }
  }
}
	</pre>
	<p>ScalaはErlangのアクターモデルを実装している</p>
  </article>

  <article>
    <h3>Actor</h3>
  	<p>メッセージ送信（!）やactor、loop、receive</p>
	<p>いずれも組み込み演算ではない</p>
	<p>Scalaのアクターライブラリーで定義されている</p>
    <br>
	<p>Scalaの中で新しい言語を作ることすら可能</p>
	<p>興味があったら<a href="http://d.hatena.ne.jp/nowokay/20111109#1320815540" target="blank">Scalaでパーサーを作ってみる</a>を見てね</p>
  </article>

  <article class="title">
    <h2 style="font-size:130%">Scalaがスケーラブルな理由</h2>
    <h3 class="subtitle" style="font-size:100%">またはオブジェクト指向と関数型プログラミングの融合</h3>
  </article>

  <article class="title">
    <h2 style="font-size:130%">Scalaはオブジェクト指向</h2>
  </article>

  <article>
    <h3>Java is OOP?</h3>
    <br><br>
    <p>Javaにはプリミティブ型がある。</p>
    <br><br>
	<p>これはリフレクションを複雑にするなど、<br>スケーラビリティを下げている。</p>
    <br><br>
    <p>純粋なオブジェクト指向じゃないよね</p>
  </article>

  <article>
    <h3>Scala is Pure OOP</h3>
    <br><br>
    <p>Scalaは純粋なオブジェクト指向</p>
	<pre>

1 + 2
    </pre>
	<p>+ は演算子に見えるが、Intオブジェクトのメソッド</p>
  </article>

  <article>
    <h3>Composition</h3>
    <br>
	<p>Scalaはオブジェクトの合成能力がすごい</p>
    <br><br>
	<p>Traitはメソッドとフィールドをカプセル化したもの。</p>
	<p>Traitを使うとミックスインのような事が可能となる。</p>
  </article>

  <article class="title">
    <h2 style="font-size:130%">Scalaは関数型言語</h2>
  </article>

  <article>
    <h3>first class values</h3>
	<h4>Scalaでは関数もリテラル</h4>
    <pre>

//普通の関数
def 関数名(引数:型, …) = 本体
//関数リテラル
(引数:型, …) => 本体

//こんな風に使える
args.foreach(arg => println(arg))
    </pre>
  </article>

  <article>
    <h3>Imutable</h3>
	<h4>メソッドは副作用を持ってはいけない</h4>
    <br><br>
	<p>Scalaは完璧ではない</p>
	<p>イミュータブルなデータ構造多く用意している</p>
	<p>つまり副作用のないメソッドを容易に作れる</p>
  </article>


  <article class="title">
    <h2 style="font-size:130%">Scalaを選ぶ理由</h2>
  </article>

  <article>
    <h3>Compatibility</h3>
	<h4>互換性（Javaとの共存）</h4>
    <br><br>
	<p>ScalaはJavaのライブラリーを多用している。</p>
	<p>ScalaからJavaを使うために特別な構文などはない。</p>
	<p>実際MyBatisとかもさくっと使えました。</p>
  </article>

  <article>
    <h3>Elegant</h3>
	<h4>簡潔性</h4>
    <pre>

//これはJava
class MyClass {
  private int index;
  private String name;
  public MyClass(int index, String name) {
    this.index = index;
    this.name = name;
  }
}
    </pre>
  </article>

  <article>
    <h3>Elegant</h3>
	<h4>簡潔性（Javaの半分以下のコード量）</h4>
	<br>
	<pre>

// Scalaならこれだけ
class MyClass(index: Int, name: String)
    </pre>
	<p>行数が減れば入力が楽、そして理解する労力も減る？</p>
  </article>

  <article>
    <h3>high-level programming language</h3>
	<h4>高水準</h4>
	<p>例えばStringの変数の中に大文字があるかどうかを知る関数</p>
    <pre>

// Java
boolean nameHasUpperCase = false;
for (int i = 0; i < name.length(); ++i) {
    if (Character.isUpperCase(name.charAt(i))) {
        nameHasUpperCase = true;
        break;
    }
}
	</pre>
  </article>

  <article>
    <h3>high-level programming language</h3>
	<h4>抽象度の高いコード、新しい制御構造を定義できる表現力</h4>
    <pre>

val nameHasUpperCase = name.exists(_.isUpperCase)
	</pre>
	<p>文字列をより高い水準の存在として扱い、<br>複雑さを緩和している。</p>
	<p>Javaでも似たような制御構造を作ることは可能だが面倒。</p>
	<p>関数リテラルはプログラムは短くてキレイなものとする。</p>
  </article>

  <article>
    <h3>Static Typing</h3>
	<h4>簡潔性</h4>
	<p>静的型付け言語は一般的には冗長だと言われている</p>
	<p>型を指定しないとかけない。</p>
	<p>コーディング量が増える。</p>
    <br><br>
    <ul class="build">
	<p>Scalaでは強力な型推論があるので簡潔に書ける。</p>
    </ul>
  </article>

  <article>
    <h3>Static Typing</h3>
	<h4>柔軟性</h4>
	<p>型が静的である事自体が制限になる。</p>
	<p>将来の変化の足かせになる。</p>
    <br><br>
    <ul class="build">
	<p>Scalaではパターンマッチングと強力な合成の力で<br>かなり柔軟に書ける。</p>
    </ul>
  </article>

  <article>
    <h3>Static Typing</h3>
	<h4>検証可能性</h4>
	<p>真偽値が整数に加算されていない</p>
	<p>文字列の集合に文字列以外が追加されない</p>
	<p>コンパイル時に検出可能</p>
    <br><br>
    <ul class="build">
	<p>テストで証明できるのはエラーの存在だけ</p>
	<p>エラーの不在ではない！</p>
    </ul>
  </article>

  <article>
    <h3>Static Typing</h3>
	<h4>安全なリファクタリング</h4>
	<p>コンパイル時に検出されるエラーがリファクタリング時のセーフティネットとなる。</p>
    <br><br>
    <ul class="build">
	<p>影響範囲の特定が楽</p>
    </ul>
  </article>

  <article>
    <h3>Static Typing</h3>
	<h4>ドキュメント性の向上</h4>
    <pre>def f(x: String) = …)</pre>
	<p>fの引数がStringでなければならないことがわかる。</p>
	<p>ただ、これはやだ</p>
    <pre>val x: HashMap[Int, String] = new HashMap[Int, String]()</pre>
	<pre>
val x = new HashMap[Int, String]()
val x: Map[Int, String] = new HashMap()</pre>
	<p>型推論してくれるScalaならこれでいい</p>
  </article>

  <article class="title">
  <h2 style="font-size:130%">Scalaのさまざまなルーツ</h2>
  </article>

  <article>
    <h3>Roots</h3>
    <br>
    <ul class="build">
    <li>表面的なレベルではJavaとC#の構文を多く採用</li>
    <li>徹底したオブジェクトモデルはSmalltalk、Ruby</li>
    <li>普遍的なネストの考え方でAlgol、Sumula等</li>
    <li>高階関数はHaskell等</li>
    <li>アクターベースの並行処理でErlang</li>
    <li>etc...</li>
    </ul>
  </article>

  <article class="title">
  <h2 style="font-size:130%">まとめ</h2>
  </article>

  <article>
    <h3>We will love Scala</h3>
    <br>
    <ul class="build">
    <li>Scalaは色々便利そう</li>
    <li>だけど、しっかり勉強しないと使えない</li>
    <li>Javaからの移行だと、型システムと関数型が難しそう</li>
    </ul>
  </article>

  <article class="title">
  <h2 style="font-size:130%">Scalaプログラミングの第一歩</h2>
  </article>

  <article>
    <h3>Scalaプログラミング第一歩</h3>
    <ul style="font-size:60%">
	  <li>２．１［ステップ１］Scalaインタープリターの使い方を学ぶ</li>
      <li>２．２［ステップ２］変数を定義する</li>
      <li>２．３［ステップ３］関数を定義する</li>
      <li>２．４［ステップ４］簡単なScalaスクリプトを書く</li>
      <li>２．５［ステップ５］whileによるループ、ifによる分岐</li>
      <li>２．６［ステップ６］foreachとforによる反復実行</li>
      <li>２．７まとめ</li>
    </ul>
  </article>

  <article class="title">
  <h2 style="font-size:130%">Scalaインタープリターの使い方を学ぶ</h2>
    <h3 class="subtitle">Step1</h3>
  </article>

  <article>
    <h3>Step1</h3>
	<pre>
$scala

scala> 1 + 2

res0: Int = 3</pre>
	<p>計算された値を参照する自動生成またはユーザー定義で作られた名前</p>
	<p>コロンと式の型</p>
	<p>等号</p>
	<p>式評価の結果</p>
  </article>

  <article>
    <h3>Step1</h3>
	<p>res0は実際に使える</p>
	<pre>
scala> res0 * 3

res1: Int = 9</pre>
	<br>
    <p>みんなの大好き「Hello world」</p>
    <pre>
scala> println("Hello, world!")

Hello, world!</pre>
  </article>

  <article class="title">
  <h2 style="font-size:130%">変数を定義する</h2>
    <h3 class="subtitle">Step2</h3>
  </article>

  <article>
    <h3>Step2</h3>
	<p>res0は実際に使える</p>
	<pre>
scala> val msg = "Hello, world!"
msg: java.lang.String = Hello, world!</pre>
    <p>型を明示的に指定したいときは</p>
	<pre>
scala> val msg2: java.lang.String = "Hello, world!"
msg2: java.lang.String = Hello, world!

scala> val msg3: String = "Hello, world!"
msg3: String = Hello, world!</pre>
    <p>こんな風に使えます</p>
	<pre>
scala> println(msg)
Hello, world!</pre>
  </article>







  <article class="title">
  <h2 style="font-size:130%">ボクシングされた基本データより<br/>基本データ型を選ぶ</h2>
  </article>

  <article>
    <h3>Boxing</h3>
	<p>自動ボクシング</p>
    <pre>

Integer i = 100;
	</pre>
	<p>自動アンボクシング</p>
    <pre>

int i = new Integer(100);
	</pre>

  </article>

  <article>
    <h3>What's wrong</h3>
	<br>
	<p>欠陥を見つけられますか？</p>
	<br>
    <pre>

Comparator&lt;Integer&gt; naturalOrder = new Comparator&lt;Integer&gt;() {
    public int compare(Integer first, Integer second) {
        return first &lt; second ? -1 : (first == second ? 0 : 1);
    }
};
	</pre>
	<p>Let's see the <a href="https://github.com/wataru420/EffectiveJava/blob/master/src/part8/term49/Main.java">sample</a>.</p>
  </article>

  <article>
    <h3>Think</h3>
	<p>なぜnull pointer??</p>
	<br>
    <pre>

static Integer i;

public static void main(String[] args) {
    if (i == 42)
        System.out.println("Unbelievable");
}
	</pre>
	<p>Let's see the <a href="https://github.com/wataru420/EffectiveJava/blob/master/src/part8/term49/Main2.java">sample</a>.</p>
  </article>

  <article>
    <h3>Baaad performance!</h3>
	<p>このプログラムは遅い</p>
	<br>
    <pre>

public static void main(String[] args) {
    Long sum = 0L;
    for (long i = 0; i &lt; Integer.MAX_VALUE; i++) {
        sum += i;
    }
    System.out.println(sum);
}
	</pre>
	<p>Let's see the <a href="https://github.com/wataru420/EffectiveJava/blob/master/src/part8/term49/Main3.java">sample</a>.</p>
  </article>

  <article>
    <h3>まとめ</h3>
	<br>
	<p>自動ボクシングはなるだけ避けよう</p>
	<br>
    <img style="padding-left:70%;" src="http://pds.exblog.jp/pds/1/201102/13/35/c0022635_21354138.jpg">
  </article>

  <article class="title">
  <h2 style="font-size:130%">他の型が適切場な場所では、<br/>文字列を避ける</h2>
  </article>

  <article>
    <h3>String is poor</h3>
	<p>文字列は</p>
	</pre>
    <ul class="build">
		<li>他の値型に対する代替としては貧弱です<br><br></li>
		<li>列挙型に対する代替としては貧弱です<br><br></li>
		<li>集合型に対する代替としては貧弱です<br><br></li>
    <pre>

//集合型として、文字列の不適切な仕様
String compoundKey = className + "#" + i.next()
	</pre>

    </ul>
  </article>

  <article>
    <h3>Bad ThreadLocal</h3>
    <pre>

public class ThreadLocal {
    private ThreadLocal() { } //インスタンス化不可能
    
    //名前付き変数に対するカレントスレッドの値を設定する
    public static void set(String key, Object value);
    
    //名前付き変数に対するカレントスレッドの値を返す
    public static Object get(String key);
}
	</pre>
	<p>Keyを偽造できたり、名前がダブっちゃう可能性がある</p>
  </article>

  <article>
    <h3>Use capability</h3>
    <pre>

public class ThreadLocal {
    private ThreadLocal() { } //インスタンス化不可能
    
    public static class Key {//文字列を偽造できないキー (ケーパビリティ)
        Key();
    }
    
    //一意の偽造できないキーを生成する
    public static Key getKey() {
        return new Key();
    }
    
    public static void set(Key key, Object value);
    public static Object get(Key key);
}
	</pre>
  </article>

  <article>
    <h3>No need Static</h3>
    <pre>

public class ThreadLocal {
    public ThreadLocal();
    public void set(Object value);
    public Object get();
}
	</pre>
	<p>KeyはThread毎につけるのだから</p>
	<p>Thread毎にインスタンス作れば解決</p>
  </article>

  <article>
    <h3>Use generic</h3>
    <pre>

public class ThreadLocal<T> {
    public ThreadLocal();
    public void set(T value);
    public T get();
}
	</pre>
	<p>ジェネリック化すればさらに安全</p>
	<p>取り出したときにキャストする必要がなくなる</p>
  </article>

  <article class="title">
  <h2 style="font-size:130%">文字列結合のパフォーマンスに用心する</h2>
  </article>

  <article>
    <h3>This is slow</h3>
    <pre>

public String statement() {
    String result = "";
    for (int i = 0; i &lt; numItem(i); i++)
        result += lineForItem(i); //String結合
    return result;
}
	</pre>
	<p>結合演算子毎にインスタンスを生成するっぽい</p>
  </article>

  <article>
    <h3>Use StringBuilder</h3>
    <pre>

public String statement() {
    StringBuilder b = new StringBuilder(numItems() * LINE_WIDTH)
    for (int i = 0; i &lt; numItem(i); i++)
        b.append(lineForItem(i));
    return b.toString();
}
	</pre>
	<p>結合する数が多い場合はStringBuilderが圧倒的に速い</p>
	<p>少ない場合はあまり意味ない場合もある</p>
	<p>ThreadSafeにしたいときはStringBuffer</p>
	<p>予め使う文字数で初期化しといたほうが速い</p>
	<p>Let's see the <a href="https://github.com/wataru420/EffectiveJava/blob/master/src/part8/term51/Main3.java">sample</a>.</p>
  </article>

<!--
  <article class="title">
  <h2 style="font-size:130%">InterfaceでObjectを参照する</h2>
  </article>


  <article class="title">
  <h2 style="font-size:130%">ReflectionよりInterfaceを選ぶ</h2>
  </article>


  <article class="title">
  <h2 style="font-size:130%">ネイティブメソッドを注意して使用する</h2>
  </article>


  <article class="title">
  <h2 style="font-size:130%">注意して最適化する</h2>
  </article>


  <article class="title">
  <h2 style="font-size:130%">一般的に受け入れらている命名規則を守る</h2>
  </article>
  -->
 
  <article>
    <h3>The End</h3>
    <p>Wataru Fukunaga</p>
    <p><a href="http://twitter.com/wataru420">@wataru420</a> 
      | <a href="http://ameblo.jp/wataru420">amebaId:wataru420</a>
    <br><br>
    <p>Slides available at <a href="http://goo.gl/SVfmP">http://goo.gl/SVfmP</a></p>
    <p>Repo at <a href="https://github.com/wataru420/EffectiveJava/tree/master/src/part8">github.com/wataru420/EffectiveJava</a></p>
 
  </article>

</section>
<script type="text/javascript">

	var _gaq = _gaq || [];
	_gaq.push(['_setAccount', 'UA-27158263-1']);
	_gaq.push(['_trackPageview']);

	(function() {
	 var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
	 ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
	 var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
	 })();

</script>
<!--[if IE]>
<script src="http://ajax.googleapis.com/ajax/libs/chrome-frame/1/CFInstall.min.js"></script>
<script>CFInstall.check({mode: 'overlay'});</script>
<![endif]-->

</body>
</html>
